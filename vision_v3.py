import os
import re
import json
import inspect
import pygame
import random
import spotipy
import threading

import google.generativeai as genai

from dotenv import load_dotenv

from jarvis_functions.essential_functions.enhanced_elevenlabs import generate_audio_from_text
from jarvis_functions.essential_functions.voice_input import record_text
from jarvis_functions.shazam_method import recognize_audio
from jarvis_functions.word_document import openWord
from jarvis_functions.whatsapp_messaging_method import whatsapp_send_message
from jarvis_functions.take_screenshot import take_screenshot
from jarvis_functions.play_spotify import play_song, play_music, pause_music
from jarvis_functions.mail_related import readMail, create_appointment, send_email
from jarvis_functions.gemini_vision_method import gemini_vision
from jarvis_functions.call_phone_method import call_phone
from jarvis_functions.send_message_instagram.input_to_message_ai import generate_message

# Import the new UI class
from jarvis_ui import JarvisUI

load_dotenv()

# Initialize Spotify
client_id = os.getenv("SPOTIFY_CLIENT_ID")
client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")
sp = spotipy.Spotify(auth_manager=spotipy.SpotifyOAuth(
    client_id=client_id,
    client_secret=client_secret,
    redirect_uri='http://localhost:8888/callback',
    scope='user-library-read user-read-playback-state user-modify-playback-state'))

# Initialize Gemini
os.environ["GEMINI_API_KEY"] = os.getenv("GEMINI_KEY")
genai.configure(api_key=os.environ["GEMINI_API_KEY"])

model = genai.GenerativeModel(model_name="gemini-2.5-flash")

system_instructions = (
    "–í–∏–µ —Å—Ç–µ –î–∂–∞—Ä–≤–∏—Å, –ø–æ–ª–µ–∑–µ–Ω –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–µ–Ω AI –∞—Å–∏—Å—Ç–µ–Ω—Ç/–∞–≥–µ–Ω—Ç. "
    "–í–∏–Ω–∞–≥–∏ –æ—Ç–≥–æ–≤–∞—Ä—è–π—Ç–µ –ø—Ä–æ—Ñ–µ—Å–∏–æ–Ω–∞–ª–Ω–æ –∏ –∫—Ä–∞—Ç–∫–æ, –Ω–æ —Å—ä—â–æ —Å–µ –¥—Ä—ä–∂ –ø—Ä–∏—è—Ç–µ–ª—Å–∫–∏. "
    "–ü–æ–¥–¥—ä—Ä–∂–∞–π—Ç–µ –æ—Ç–≥–æ–≤–æ—Ä–∏—Ç–µ –∫—Ä–∞—Ç–∫–∏, –Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–∏. "
    "–û—Å–∏–≥—É—Ä–µ—Ç–µ, —á–µ –≤—Å–∏—á–∫–∏ –æ—Ç–≥–æ–≤–æ—Ä–∏ —Å–∞ —Ñ–∞–∫—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–∏ —Ç–æ—á–Ω–∏ –∏ –ª–µ—Å–Ω–∏ –∑–∞ —Ä–∞–∑–±–∏—Ä–∞–Ω–µ. "
    "–¢–≤–æ—è—Ç–∞ —Ä–∞–±–æ—Ç–∞ –µ —Å–ª–µ–¥–Ω–∞—Ç–∞: –ü—Ä–∏ –ø–æ–ª—É—á–∞–≤–∞–Ω–µ –Ω–∞ –∫–æ–º–∞–Ω–¥–∞ –æ—Ç –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è, "
    "—Ç–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –æ–ø—Ä–µ–¥–µ–ª–∏—à –¥–∞–ª–∏ –µ –∫–æ–º–∞–Ω–¥–∞ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –≤—ä–ø—Ä–æ—Å."

    "–ê–∫–æ –µ –≤—ä–ø—Ä–æ—Å, –æ—Ç–≥–æ–≤–æ—Ä–∏ –Ω–∞ –Ω–µ–≥–æ –∫—Ä–∞—Ç–∫–æ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ. "
    "–ö–æ–≥–∞—Ç–æ –µ –ø–æ–¥—Ö–æ–¥—è—â–æ, –¥–æ–±–∞–≤—è–π—Ç–µ —Å—Ç–∏–ª–æ–≤–∏ –º–∞—Ä–∫–µ—Ä–∏ –∑–∞ –µ–º–æ—Ü–∏—è –∏–ª–∏ –Ω–∞—á–∏–Ω –Ω–∞ –∏–∑—Ä–∞–∑—è–≤–∞–Ω–µ, "
    "–Ω–∞–ø—Ä–∏–º–µ—Ä [whispers], [laughs], [sarcastically], [cheerfully], [angrily], "
    "–∑–∞ –¥–∞ –ø–æ–¥—Å–∫–∞–∂–µ—Ç–µ –Ω–∞ TTS –∫–∞–∫ –¥–∞ —á–µ—Ç–µ —Ç–µ–∫—Å—Ç–∞. "
    "–í–∏–Ω–∞–≥–∏ –æ—Å—Ç–∞–≤—è–π—Ç–µ –º–∞—Ä–∫–µ—Ä–∏—Ç–µ –≤ —Å–∫–æ–±–∏ [] –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ —Ç–µ–∫—Å—Ç–∞."

    "–û–±–∞—á–µ –∞–∫–æ –µ –∫–æ–º–∞–Ω–¥–∞, —Ç—Ä—è–±–≤–∞ –¥–∞ –Ω–∞–ø–∏—à–µ—à 'command'."
    "–°–ª–µ–¥ —Ç–æ–≤–∞ –Ω–∞ –Ω–æ–≤ —Ä–µ–¥, —Ç—Ä—è–±–≤–∞ –¥–∞ –Ω–∞–ø–∏—à–µ—à –∏–º–µ—Ç–æ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è—Ç–∞, –∫–æ—è—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –∏–∑–≤–∏–∫–∞ (–∫–∞—Ç–æ —Å—ä–±–µ—Ä–µ—à –ø–æ–¥—Ö–æ–¥—è—â–∞—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è), "
    "–∫–∞—Ç–æ –∏–º–∞—à –ø—Ä–µ–¥–≤–∏–¥ —Å–ª–µ–¥–Ω–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ–∏—Ç–æ –º–æ–∂–µ—à –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞—à: "

    "1. generate_message(user_input) - –ò–∑–ø—Ä–∞—â–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ –≤ Instagram –Ω–∞ –ø–æ—Å–æ—á–µ–Ω–∏—è –ø–æ–ª—É—á–∞—Ç–µ–ª. –§—É–Ω—Ü–∏—è—Ç–∞ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä user_input –æ—Ç —Ç–∏–ø str, –æ—Ç —Ç–µ–±–µ –ø—Ä–æ—Å—Ç–æ —Å–µ –∏—Å–∫–∞ –¥–∞ —Å–ª–æ–∂–∏—à –∫–∞—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è —Ç–µ–∫—Å—Ç –Ω–∞ user-a. "
    "2. gemini_vision() - –ò–∑–ø–æ–ª–∑–≤–∞ Gemini Vision –º–æ–¥–µ–ª –∫–æ–π—Ç–æ —Ä–∞–∑–ø–æ–∑–Ω–∞–≤–∞ –∫–∞–∫–≤–æ –∏–º–∞ –Ω–∞ —É–µ–± –∫–∞–º–µ—Ä–∞—Ç–∞. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "3. take_screenshot() - –ò–∑–ø–æ–ª–∑–≤–∞ Gemini Vision –º–æ–¥–µ–ª –∫–æ–π—Ç–æ —Ä–∞–∑–ø–æ–∑–Ω–∞–≤–∞ –∫–∞–∫–≤–æ –∏–º–∞ –Ω–∞ –µ–∫—Ä–∞–Ω–∞. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏. "
    "4. play_song(user_input) - –ü—É—Å–∫–∞ –ø–µ—Å–µ–Ω –≤ Spotify. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä user_input –æ—Ç —Ç–∏–ø str, –∫–æ–π—Ç–æ —Å—ä–¥—ä—Ä–∂–∞ –∏–º–µ—Ç–æ –Ω–∞ –ø–µ—Å–µ–Ω—Ç–∞."
    "5. pause_music() - –ü–∞—É–∑–∞ –Ω–∞ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–µ—Å–µ–Ω –≤ Spotify. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "6. change_jarvis_voice() - –ü—Ä–æ–º–µ–Ω—è –≥–ª–∞—Å–∞ –Ω–∞ –î–∂–∞—Ä–≤–∏—Å. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "7. change_jarvis_name() - –ü—Ä–æ–º–µ–Ω—è –∏–º–µ—Ç–æ –Ω–∞ –î–∂–∞—Ä–≤–∏—Å. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "8. readMail() - –ß–µ—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ –∏–º–µ–π–ª–∏ –æ—Ç Outlook. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "9. create_appointment() - –°—ä–∑–¥–∞–≤–∞ –Ω–æ–≤–æ —Å—ä–±–∏—Ç–∏–µ –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–∞ –Ω–∞ Outlook. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "10. send_email() - –ò–∑–ø—Ä–∞—â–∞ –∏–º–µ–π–ª —á—Ä–µ–∑ Outlook. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "11. openWord() - –û—Ç–≤–∞—Ä—è Microsoft Word –∏ —Å—ä–∑–¥–∞–≤–∞ –Ω–æ–≤ –¥–æ–∫—É–º–µ–Ω—Ç. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."
    "12. recognize_audio() - –†–∞–∑–ø–æ–∑–Ω–∞–≤–∞ –ø–µ—Å–µ–Ω —á—Ä–µ–∑ —Å–ª—É—à–∞–Ω–µ –Ω–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞. –§—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –∏–∑–∏—Å–∫–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏."

    "–í–∏–Ω–∞–≥–∏ –≤—Ä—ä—â–∞–π –æ—Ç–≥–æ–≤–æ—Ä–∞ –≤ JSON —Ñ–æ—Ä–º–∞—Ç, –∫–∞—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞—à —Å–ª–µ–¥–Ω–∞—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞: "
    "{'response_type': 'command', 'function': 'function_name', 'parameters': {'param1': 'value1', 'param2': 'value2'}}"
    "–∏–ª–∏ –∞–∫–æ –µ –≤—ä–ø—Ä–æ—Å: ""{'response_type': 'answer', 'answer': 'your answer here'}"
)

chat = model.start_chat(history=[{"role": "user", "parts": [system_instructions], }])

wake_word_detected = False

# Initialize UI
ui = JarvisUI(width=1920, height=1080, fullscreen=False)

def fetch_current_track():
    """Fetch the current playing track and its album cover."""
    try:
        current_track = sp.currently_playing()
        if current_track and current_track['is_playing']:
            song = current_track['item']['name']
            artist = ", ".join([a['name'] for a in current_track['item']['artists']])
            album_cover_url = current_track['item']['album']['images'][0]['url']
            progress_ms = current_track['progress_ms']
            duration_ms = current_track['item']['duration_ms']
            return song, artist, album_cover_url, progress_ms, duration_ms
        return None, None, None, 0, 0
    except Exception as e:
        print(f"Error fetching track: {e}")
        return None, None, None, 0, 0

def chatbot():
    """Main chatbot logic."""
    global wake_word_detected

    print("Welcome to Vision! Say any of the models name to activate. Say 'exit' to quit.")

    while True:
        if not wake_word_detected:
            print("Waiting for wake word...")
            user_input = record_text()

            if not user_input:
                print("Sorry, I didn't catch that. Please try again.")
                continue

            user_input_lower = user_input.lower()
            if any(word in user_input_lower for word in ["–¥–∂–∞—Ä–≤–∏—Å", "–¥–∂–∞—Ä–≤–∏", "–¥–∂–µ—Ä–≤–∏—Å", "jarvis", "—á–µ—Ä–≤–∏"]):
                wake_word_detected = True
                pygame.mixer.music.load("sound_files/beep.flac")
                pygame.mixer.music.play()

                print("‚úÖ Wake word detected!")
                ui.model_answering = True
                ui.is_generating = False

                response = random.choice(ui.jarvis_responses)
                generate_audio_from_text(text=response, voice=ui.jarvis_voice)

                ui.model_answering = False
                ui.is_generating = True
            else:
                continue

        print("Listening for commands...")
        user_input = record_text()

        if not user_input:
            print("Error: No input detected.")
            wake_word_detected = False
            continue

        response = chat.send_message(user_input)
        text = response.text.strip()

        try:
            clean_text = re.sub(r"```(?:json)?|```", "", text).strip()
            clean_text = clean_text.replace("'", '"')
            data = json.loads(clean_text)
        except json.JSONDecodeError as e:
            print(f"‚ö†Ô∏è Could not parse JSON: {e}")
            wake_word_detected = False
            continue

        # Handle answer
        if data.get("response_type") == "answer":
            answer = data.get("answer", "")
            print("ü§ñ Jarvis:", answer)
            generate_audio_from_text(answer, ui.jarvis_voice)

        # Handle command
        elif data.get("response_type") == "command":
            function_name = data.get("function")
            params = data.get("parameters", {})
            func = globals().get(function_name)
            if func:
                try:
                    sig = inspect.signature(func)
                    if len(sig.parameters) == 0:
                        func()
                    elif len(sig.parameters) == 1:
                        func(*params.values())
                    else:
                        func(**params)
                    print(f"‚úÖ Function {function_name} executed successfully")
                    ui.update_status(f"Executed: {function_name}")
                except Exception as e:
                    print(f"‚ùå Error executing function: {e}")
                    ui.update_status(f"Error: {function_name}")
            else:
                print(f"‚ö†Ô∏è Function {function_name} not found")

        ui.model_answering = False
        ui.is_generating = False

        wake_word_detected = False


# Main Loop
def main():
    running = True

    # Run chatbot in a separate thread
    chatbot_thread = threading.Thread(target=chatbot, daemon=True)
    chatbot_thread.start()

    # Track time for Spotify updates
    last_spotify_update = 0

    while running:
        # Event Handling
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # Fetch current track periodically (every 3 seconds)
        current_time = pygame.time.get_ticks()
        if current_time - last_spotify_update > 3000:
            song, artist, album_cover_url, progress_ms, duration_ms = fetch_current_track()
            if song and artist:
                ui.update_song_info(song, artist, progress_ms, duration_ms)
            last_spotify_update = current_time

        # Render the UI
        ui.render()

    ui.quit()


if __name__ == "__main__":
    main()